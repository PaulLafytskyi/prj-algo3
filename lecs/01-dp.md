# Динамическое программирование

Динамическое программирование — это "эффективный" полный перебор, который использует мемоизацию для борьбы с эффектом экспоненциального взрыва количества вариантов решений. ДП применимо только в тех случаях, когда задача имеет оптимальную рекурсивную структуру: оптимальное решение всей задачи может быть выражено через комбинацию локального решения и оптимального решения подзадачи, из которой исключен текущий элемент.

Этапы решения задачи с помощью ДП:

1. Разбить задачу на вложенные друг в друга подзадачи
2. Угадать часть решения: поиск части, которая решается эвристически
3. Найти рекуррентное соотношение, которое позволяет перейти от вложенной задачи к следующей большей
4. Реализация заполнения таблицы (кодирование рекуррентного соотношения с мемоизацией)
5. Нахождение решения всей задачи на основании заполненной таблицы (часто включает т.н. "декодирование" последовательности шагов, которые приводят к оптимальному решению, для чего используется таблица обратных указателей)

ДП бывает:

- снизу-вверх (таблица заполняется в цикле)
- сверху-вниз (с помощью рекурсии)

## Мемоизация

Мемоизация — это один из базовых способов оптимизации скорости алгоритмов за счет сохранения результатов (промежуточных) вычислений, которые используются более одного раза. Часто мемоизация — это выигрыш во времени за счет потери места, хотя мемоизация может привести и к оптимальному использованию места.

Пример использования мемоизации, которая приводит к оптимальному решению с точки зрения как времени исполнения, так и места — вычисление чисел Фибоначчи.

Наивное решение в лоб (`fib(x) = fib(x-1) + fib(x-2)`) приводит к эспоненциальному взрыву из-за постоянных дополнительных вычислений (`fib(x-1)` также требует вычисления `fib(x-2)`). Решение с мемоизацией избавляется от необходимости повторных вычислений.

Наивное решение:

```
(defun fib (n)
  (case n
    ((1 2) 1)
    (otherwise (+ (fib (- n 1))
                  (fib (- n 2))))))
```

Решение с мемоизацией сверху-вниз:

```
(defun fib (n &optional (fib (make-array n :initial-element nil)))
  ;; Массив fib используется для мемоизации.
  ;; Если его ячейка не пустая (NIL), то промежуточное значение
  ;; уже было вычислено - просто возвращаем его.
  (or (aref fib (- n 1))
      ;; Иначе производим рекурсивное вычисление и запоминаем
      ;; в текущей ячейке массива.
      ;; Операция setf возвращает записанное значение
      (setf (aref fib (- n 1))
            (case n
              ((1 2) 1)
              (otherwise (+ (fib (- n 2) fib)
                            (fib (- n 1) fib)))))))
```

Решение с мемоизацией снизу-вверх:

```
(defun fib (n)
  (let ((fib (make-array n :initial-element 1)))
    (when (> n 2)
      (dotimes (i n)
        (setf (aref fib (- n 1))
              (+ (aref fib (- n 2))
                 (aref fib (- n 1))))))
    (aref fib (- n 1))))
```


## Известные алгоритмы, которые используют подход ДП:

- FFT
- backprop
- алгоритм Витерби
- выравнивание (justification) текста
- алгоритмы LCS, редакционное расстояние и diff
- CKY-парсинг
- и [другие](https://www.quora.com/What-are-some-real-world-problems-that-have-been-solved-with-dynamic-programming)


## Литература

- https://www.youtube.com/watch?v=qadw0BRKeMk
- http://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches
- https://loveforprogramming.quora.com/Backtracking-Memoization-Dynamic-Programming
- https://www.quora.com/I-want-to-learn-memoization-What-are-some-links-with-problems-from-SPOJ-Topcoder-Codeforces/answer/Laurentiu-Cristian-Ion
- https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-19-dynamic-programming-i-fibonacci-shortest-paths/
