# Алгоритмы поиска кратчайшего пути

## Алгоритм Дейкстры

Поиск кратчайшего пути в направленном графе с положительными весами и возможными циклами методом жадного перехода в вершину, длина маршрута до которой от начальной кратчайший.

На каждой итерации алгоритма уточняется минимальное расстояние от исходной вершины до всех остальных, которое изначально устанавливается равным бесконечности. Этот процесс называется **релаксацией** (поскольку уточнение происходит в сторону уменьшения). На каждом шаге выбирается вершина (`i`), расстояние до которой минимальное (изначально, это исходная вершина) и анализируются все исходящие из нее ребра. Для каждой достижимой из нее вершины (`j`) оценка ее веса (`dp[j]`) с суммой оценки веса текущей вершины (`dp[i]`) и веса ребра между вершинами (`w[i, j]`). Если для какого-то из ребер эта сумма оказывается меньше, то это приводит к обновлению веса вершины (`dp[j] = dp[i] + w[i, j]`). После того, как будут просмотренны все вершины (или же вершиной с минимальным весом будет конечная вершина), алгоритм завершается. Маршрут находится по обратным ссылкам, как в алгоритмах динамического программирования.

Этот алгоритм позволяет найти все кратчайшие пути за время, которое зависит от выбора структуры, которая используется для определения ближайшей вершины:

- простая последовательность: `O(V^2 + E)`, т.к. нужно посетить все вершины и в каждой выбрать следующую за время `V`, а также 1 раз просмотреть все ребра
- бинарная куча: `O(V * log V + E * log V)`, т.к. нужно посетить каждую вершину и каждое ребро и для каждой вершины выбрать следующую (heap extract-min - `O(log V)`), а для каждого ребра обновить вес для одной вершины в куче (`O(log V)`)
- куча Фибоначчи: `O(V * log V + E)`, т.к. обновление веса вершины для такой кучи происходит за амортизированно константное время


## Алгоритм А*

Этот алгоритм является развитием алгоритма Дейкстры, добавляя в формулу оценки веса дополнительное слагаемое: минимальную оценку веса оставшейся части маршрута. Такая оценка не всегда возможна, а когда возможна, она является эвристической, т.е. не всегда самая низкая оценка соответствует самому короткому маршруту. Тем не менее, в большинстве практических задач это так.є

Эвристика алгоритма A* должна удовлетворять правилу треугольника.


## Алгоритм Беллмана-Форда

Этот алгоритм работает по схожему принципу с алгоритмом Дейкстры, но в отличие от него, в нем релаксация производится не для самой перспективной (ближайшей) вершины, а для всех. Это позволяет решать задачу в случае наличия в графе ребер с отрицательными весами, что не доступно для алгоритма Дейкстры.

Сложность алгоритма Беллмана-Форда — `O(V * E)`, т.к. для его завершения, в общем случае, нужно выполнить `V-1` цикл релаксации для всех вершин, который требует просмотра всех ребер графа. Однако, если после текущего цикла ни один из весов вершин не изменился, работу алгоритма можно останавливать.

Также алгоритм позволяет найти негативный цикл в графе: если после `V-1` итерации произвести еще одну итерацию, которая приведет к уменьшению веса каких-то вершин, это будет означать наличие такого цикла.


## Алгоритм Флойда-Уоршолла

Этот алгоритм позволяет найти кратчайшие пути сразу между всеми вершинами графа. Он использует матрицу смежности и имеет сложность `O(V^3)`. (Нужно понимать, что если граф близок к полносвязному, то `E ~ V^2`, т.е. сложность алгоритма Беллмана-Форда — также порядка `O(V^3)`).

Идея агоритма: последовательная релаксация оценки расстояния между каждой вершиной в матрице смежности, начиная с расстояния между ними через 1 ребро (известно из графа), далее — через 2 ребра, через 3 и т.д. до `V-1` ребер.


## Литература

- https://sadakurapati.wordpress.com/2014/10/15/graphs-trees-shortest-path-bfs-dijkstra-bellman-ford/
- http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/
- http://theoryofprogramming.com/2015/01/19/bellman-ford-algorithm/
- http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/
- https://www.hackerearth.com/practice/notes/heaps-and-priority-queues/
- http://www.growingwiththeweb.com/data-structures/fibonacci-heap/overview/
- http://stackoverflow.com/questions/19508526/what-is-the-intuition-behind-the-fibonacci-heap-data-structure
- http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
- http://planning.cs.uiuc.edu/node417.html
- https://www.quora.com/Is-Dijkstras-Algorithm-a-greedy-algorithm-or-a-dynamic-programming-algorithm
- http://stackoverflow.com/questions/24140623/is-dijkstras-algorithm-dynamic-programming
